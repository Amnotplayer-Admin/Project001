#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ระบบทำนายช่องโหว่ในซอร์สโค้ดแบบง่าย (Simple Vulnerability Predictor)
ใช้เฉพาะ Python built-in modules ไม่ต้องติดตั้ง packages เพิ่มเติม

พัฒนาโดย: AI Assistant
เวอร์ชัน: 1.0
"""

import re
import os
import json
from datetime import datetime

class SimpleVulnerabilityPredictor:
    def __init__(self):
        self.vulnerability_patterns = {
            'code_injection': [
                r'eval\s*\(',
                r'exec\s*\(',
                r'__import__\s*\(',
                r'compile\s*\('
            ],
            'sql_injection': [
                r'SELECT.*FROM.*WHERE.*\+',
                r'INSERT.*INTO.*\+',
                r'UPDATE.*SET.*\+',
                r'DELETE.*FROM.*WHERE.*\+',
                r'DROP.*TABLE.*\+',
                r'CREATE.*TABLE.*\+'
            ],
            'command_injection': [
                r'os\.system\s*\(',
                r'subprocess\.call\s*\(',
                r'subprocess\.Popen\s*\(',
                r'commands\.getoutput\s*\('
            ],
            'file_traversal': [
                r'open\s*\(\s*[^)]*\+\s*[^)]*\)',
                r'file\s*\(\s*[^)]*\+\s*[^)]*\)',
                r'os\.path\.join\s*\(\s*[^)]*\+\s*[^)]*\)'
            ],
            'pickle_deserialization': [
                r'pickle\.loads\s*\(',
                r'pickle\.load\s*\(',
                r'cPickle\.loads\s*\(',
                r'cPickle\.load\s*\('
            ],
            'http_request': [
                r'urllib\.request\.urlopen\s*\(',
                r'urllib2\.urlopen\s*\(',
                r'requests\.get\s*\(',
                r'requests\.post\s*\('
            ],
            'password_exposure': [
                r'print\s*\(\s*[^)]*password[^)]*\)',
                r'print\s*\(\s*[^)]*passwd[^)]*\)',
                r'print\s*\(\s*[^)]*secret[^)]*\)',
                r'logging\s*\(\s*[^)]*password[^)]*\)'
            ],
            'directory_traversal': [
                r'os\.listdir\s*\(\s*[^)]*\+\s*[^)]*\)',
                r'os\.chdir\s*\(\s*[^)]*\+\s*[^)]*\)',
                r'os\.makedirs\s*\(\s*[^)]*\+\s*[^)]*\)'
            ]
        }
        
        self.security_keywords = [
            'password', 'secret', 'key', 'token', 'auth', 'login', 'admin',
            'sql', 'query', 'execute', 'eval', 'exec', 'system', 'shell',
            'file', 'upload', 'download', 'path', 'directory', 'http', 'https',
            'cookie', 'session', 'csrf', 'xss', 'injection', 'overflow',
            'buffer', 'stack', 'heap', 'race', 'condition', 'deadlock'
        ]
        
        self.dangerous_functions = [
            'eval', 'exec', 'system', 'os.system', 'subprocess.call',
            'subprocess.Popen', 'commands.getoutput', 'input', 'raw_input',
            'open', 'file', 'pickle.loads', 'pickle.load', 'cPickle.loads',
            'cPickle.load', 'marshal.loads', 'marshal.load'
        ]
    
    def analyze_code(self, code):
        """วิเคราะห์โค้ดเพื่อหาช่องโหว่"""
        results = {
            'is_vulnerable': False,
            'vulnerability_count': 0,
            'vulnerabilities': [],
            'risk_level': 'LOW',
            'features': {},
            'recommendations': []
        }
        
        # สกัดคุณลักษณะพื้นฐาน
        results['features'] = self.extract_basic_features(code)
        
        # ตรวจหาช่องโหว่
        for vuln_type, patterns in self.vulnerability_patterns.items():
            for pattern in patterns:
                matches = re.findall(pattern, code, re.IGNORECASE)
                if matches:
                    results['vulnerabilities'].append({
                        'type': vuln_type,
                        'pattern': pattern,
                        'matches': len(matches),
                        'risk': self.get_risk_level(vuln_type)
                    })
                    results['vulnerability_count'] += len(matches)
        
        # ตรวจหาคำที่เกี่ยวข้องกับความปลอดภัย
        security_count = 0
        for keyword in self.security_keywords:
            security_count += code.lower().count(keyword)
        
        # ตรวจหาฟังก์ชันที่อาจเป็นอันตราย
        dangerous_count = 0
        for func in self.dangerous_functions:
            dangerous_count += code.lower().count(func)
        
        # กำหนดระดับความเสี่ยง
        if results['vulnerability_count'] > 0:
            results['is_vulnerable'] = True
            if results['vulnerability_count'] >= 5:
                results['risk_level'] = 'CRITICAL'
            elif results['vulnerability_count'] >= 3:
                results['risk_level'] = 'HIGH'
            elif results['vulnerability_count'] >= 1:
                results['risk_level'] = 'MEDIUM'
        
        # สร้างคำแนะนำ
        results['recommendations'] = self.generate_recommendations(results)
        
        return results
    
    def extract_basic_features(self, code):
        """สกัดคุณลักษณะพื้นฐานจากโค้ด"""
        features = {
            'lines': len(code.split('\n')),
            'chars': len(code),
            'words': len(code.split()),
            'security_keywords': 0,
            'dangerous_functions': 0,
            'sql_queries': 0,
            'http_usage': 0
        }
        
        # ตรวจหาคำที่เกี่ยวข้องกับความปลอดภัย
        for keyword in self.security_keywords:
            features['security_keywords'] += code.lower().count(keyword)
        
        # ตรวจหาฟังก์ชันที่อาจเป็นอันตราย
        for func in self.dangerous_functions:
            features['dangerous_functions'] += code.lower().count(func)
        
        # ตรวจหาการใช้ SQL
        sql_patterns = [
            r'SELECT', r'INSERT', r'UPDATE', r'DELETE', r'DROP', r'CREATE', r'ALTER'
        ]
        for pattern in sql_patterns:
            features['sql_queries'] += len(re.findall(pattern, code, re.IGNORECASE))
        
        # ตรวจหาการใช้ HTTP
        http_patterns = [
            r'http://', r'https://', r'urllib', r'requests', r'urllib2'
        ]
        for pattern in http_patterns:
            features['http_usage'] += len(re.findall(pattern, code, re.IGNORECASE))
        
        return features
    
    def get_risk_level(self, vuln_type):
        """กำหนดระดับความเสี่ยงของช่องโหว่"""
        high_risk = ['code_injection', 'command_injection', 'sql_injection']
        medium_risk = ['file_traversal', 'pickle_deserialization', 'directory_traversal']
        
        if vuln_type in high_risk:
            return 'HIGH'
        elif vuln_type in medium_risk:
            return 'MEDIUM'
        else:
            return 'LOW'
    
    def generate_recommendations(self, results):
        """สร้างคำแนะนำตามผลการวิเคราะห์"""
        recommendations = []
        
        if results['is_vulnerable']:
            recommendations.append("⚠️  พบช่องโหว่ในโค้ด! กรุณาตรวจสอบและแก้ไข")
            
            for vuln in results['vulnerabilities']:
                if vuln['type'] == 'code_injection':
                    recommendations.append("• หลีกเลี่ยงการใช้ eval(), exec() หรือ __import__()")
                elif vuln['type'] == 'sql_injection':
                    recommendations.append("• ใช้ parameterized queries แทนการต่อ string")
                elif vuln['type'] == 'command_injection':
                    recommendations.append("• หลีกเลี่ยงการใช้ os.system() หรือ subprocess.call()")
                elif vuln['type'] == 'file_traversal':
                    recommendations.append("• ตรวจสอบ path ก่อนเปิดไฟล์")
                elif vuln['type'] == 'pickle_deserialization':
                    recommendations.append("• หลีกเลี่ยงการใช้ pickle.loads() กับข้อมูลจากผู้ใช้")
                elif vuln['type'] == 'http_request':
                    recommendations.append("• ตรวจสอบ URL ก่อนเปิด")
                elif vuln['type'] == 'password_exposure':
                    recommendations.append("• ไม่แสดงรหัสผ่านหรือข้อมูลที่สำคัญ")
                elif vuln['type'] == 'directory_traversal':
                    recommendations.append("• ตรวจสอบ directory path ก่อนเข้าถึง")
        
        if results['features']['security_keywords'] > 10:
            recommendations.append("• โค้ดมีคำที่เกี่ยวข้องกับความปลอดภัยมาก ควรตรวจสอบเพิ่มเติม")
        
        if results['features']['dangerous_functions'] > 0:
            recommendations.append("• พบฟังก์ชันที่อาจเป็นอันตราย ควรตรวจสอบการใช้งาน")
        
        if not recommendations:
            recommendations.append("✅ โค้ดปลอดภัย ไม่พบช่องโหว่ที่ชัดเจน")
        
        return recommendations
    
    def analyze_file(self, filepath):
        """วิเคราะห์ไฟล์โค้ด"""
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                code = f.read()
            
            results = self.analyze_code(code)
            results['file_info'] = {
                'path': filepath,
                'size': os.path.getsize(filepath),
                'modified': datetime.fromtimestamp(os.path.getmtime(filepath))
            }
            
            return results
        except Exception as e:
            return {
                'error': f"ไม่สามารถอ่านไฟล์ได้: {str(e)}",
                'is_vulnerable': False
            }
    
    def save_analysis_report(self, results, filepath):
        """บันทึกรายงานการวิเคราะห์"""
        try:
            report = {
                'timestamp': datetime.now().isoformat(),
                'results': results
            }
            
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(report, f, indent=2, ensure_ascii=False, default=str)
            
            return True
        except Exception as e:
            print(f"ไม่สามารถบันทึกรายงานได้: {str(e)}")
            return False
    
    def print_analysis_results(self, results):
        """แสดงผลการวิเคราะห์ในรูปแบบที่อ่านง่าย"""
        print("\n" + "="*60)
        print("ผลการวิเคราะห์ช่องโหว่ในซอร์สโค้ด")
        print("="*60)
        
        if 'error' in results:
            print(f"❌ เกิดข้อผิดพลาด: {results['error']}")
            return
        
        # สรุปผล
        if results['is_vulnerable']:
            print(f"⚠️  พบช่องโหว่ {results['vulnerability_count']} รายการ")
            print(f"ระดับความเสี่ยง: {results['risk_level']}")
        else:
            print("✅ ไม่พบช่องโหว่")
        
        # คุณลักษณะพื้นฐาน
        print(f"\n📊 คุณลักษณะพื้นฐาน:")
        features = results['features']
        print(f"• จำนวนบรรทัด: {features['lines']}")
        print(f"• จำนวนตัวอักษร: {features['chars']}")
        print(f"• จำนวนคำ: {features['words']}")
        print(f"• คำที่เกี่ยวข้องกับความปลอดภัย: {features['security_keywords']}")
        print(f"• ฟังก์ชันที่อาจเป็นอันตราย: {features['dangerous_functions']}")
        print(f"• การใช้ SQL: {features['sql_queries']}")
        print(f"• การใช้ HTTP: {features['http_usage']}")
        
        # รายละเอียดช่องโหว่
        if results['vulnerabilities']:
            print(f"\n🚨 รายละเอียดช่องโหว่:")
            for i, vuln in enumerate(results['vulnerabilities'], 1):
                print(f"{i}. ประเภท: {vuln['type']}")
                print(f"   ความเสี่ยง: {vuln['risk']}")
                print(f"   จำนวนที่พบ: {vuln['matches']}")
        
        # คำแนะนำ
        print(f"\n💡 คำแนะนำ:")
        for rec in results['recommendations']:
            print(f"• {rec}")
        
        print("\n" + "="*60)

def main():
    """ฟังก์ชันหลักสำหรับทดสอบ"""
    predictor = SimpleVulnerabilityPredictor()
    
    print("ระบบทำนายช่องโหว่ในซอร์สโค้ดแบบง่าย")
    print("ใช้เฉพาะ Python built-in modules")
    
    # ตัวอย่างการใช้งาน
    print("\nตัวอย่างการวิเคราะห์โค้ดที่มีช่องโหว่:")
    
    vulnerable_code = '''
password = input("Enter password: ")
print(f"Password: {password}")

user_id = input("Enter user ID: ")
query = f"SELECT * FROM users WHERE id = {user_id}"

user_command = input("Enter command: ")
os.system(user_command)

filename = input("Enter filename: ")
with open(filename, 'r') as f:
    content = f.read()
    '''
    
    results = predictor.analyze_code(vulnerable_code)
    predictor.print_analysis_results(results)
    
    # บันทึกรายงาน
    predictor.save_analysis_report(results, "vulnerability_report.json")
    print("\n📄 บันทึกรายงานไปยัง: vulnerability_report.json")

if __name__ == "__main__":
    main()
